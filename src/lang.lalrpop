use std::str::FromStr;
use ast::{Expr, Opcode, VarDecl, FnDecl};

grammar;

pub file = <program>;

program = <function_declaration*>;

function_declaration: FnDecl = "fn" <identifier> /*ADD parameters*/ "->" <type_declaration> <function_block> => FnDecl::new(<>);

function_block = "{" <variable_declaration*> <statement*> "}";

variable_declaration: VarDecl = "let" <identifier> (":" <type_declaration> "=" <expression>)? ";" => VarDecl::new(<>);

statement = {
    <nonblock_expr> ";",
    <if_statement>,
    <while_statement>,
    <return_statement>,
    "{" <statement*> "}",
};

if_statement = "if" <nonblock_expr> "{" <statement*> "}" ("else" "{" <statement*> "}")?;

while_statement = "while" <nonblock_expr> "{" <statement*> "}";

return_statement = "return" <nonblock_expr?> ";";

nonblock_expr = {
    <variable>,
    <function_call>,
    <comparison>,
};

variable = {
    identifier,
    identifier "[" <nonblock_expr> "]",
}

function_call = identifier "(" (<nonblock_expr> ",")* <nonblock_expr?> ")";

comparison = {
    <expression> <relational> <expression>
};

relational = {
    "==",
    "!=",
    "<",
    ">",
    "<=",
    ">=",
};

Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::Op(<>)),
    NextTier,
};

expression = Tier<expression_operator, factor>;

factor = Tier<factor_operator, term>;

expression_operator: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

factor_operator: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

term: Box<Expr> = {
    number => Box::new(Expr::Number(<>)),
    "(" <expression> ")",
    <identifier>,
    // function calls go here
};

number: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();

identifier: Box<Expr> = r"[a-zA-Z_]\w*" => Box::new(Expr::Ident(<>.to_string()));