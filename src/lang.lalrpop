use std::str::FromStr;
use ast::{Function, VarDecl, Statement, Comparison, CmpOperator, Opcode, Type, Expr, Variable};

grammar;

pub file = <program>;

program = <function_declaration*>;

function_declaration: Function = {
    "fn" <identifier:identifier> <params:function_params> "->" <ret:type_declaration> "{" <declarations:variable_declaration*> <statements:statement*> "}" => Function {<>},
};

function_params: Vec<(Box<Expr>, Type)> = "(" <e:(<identifier> ":" <type_declaration>)?> <v:("," <identifier> ":" <type_declaration>)*> ")" => {
    match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.insert(0, e);
            v
        }
    }
};

variable_declaration: VarDecl = {
    "let" <identifier:identifier> ":" <ty:type_declaration> <expression:("=" <expression>)?> ";" => VarDecl {<>},
};

statement: Statement = {
    expression_statement,
    assign_statement,
    if_statement,
    while_statement,
    return_statement,
    statement_block,
};

expression_statement: Statement = <expression> ";" => Statement::Expression(<>);

assign_statement: Statement = <variable> "=" <expression> ";" => Statement::Assignment(<>);

if_statement: Statement = "if" <comparison> "{" <statement*> "}" <("else" "{" <statement*> "}")?> => Statement::If(<>);

while_statement: Statement = "while" <comparison> "{" <statement*> "}" => Statement::While(<>);

return_statement: Statement = "return" <expression?> ";" => Statement::Return(<>);

statement_block: Statement = "{" <statement*> "}" => Statement::Block(<>);

comparison: Comparison = <lhs:expression> <operator:relational> <rhs:expression> => Comparison {<>};

Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::Operation(<>)),
    NextTier,
};

expression = Tier<expression_operator, factor>;

factor = Tier<factor_operator, term>;

term: Box<Expr> = {
    "(" <expression> ")",
    number,
    variable,
    function_call,
};

variable: Box<Expr> = {
    identifier,
    <identifier:identifier> "[" <index:expression> "]" => Box::new(Expr::Variable(Variable::Vec {<>})),
};

function_call: Box<Expr> = <id:identifier> "(" <e:expression?> <v:("," <expression>)*> ")" => {
    let arg_list = match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.insert(0, e);
            v
        }
    };
    Box::new(Expr::FunctionCall{
        identifier: id,
        arg_list: arg_list,
    })
};

relational: CmpOperator = {
    "==" => CmpOperator::Eq,
    "!=" => CmpOperator::Ne,
    "<"  => CmpOperator::Lt,
    ">"  => CmpOperator::Gt,
    "<=" => CmpOperator::Le,
    ">=" => CmpOperator::Ge,
};

expression_operator: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

factor_operator: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

type_declaration: Type = {
    "i64" => Type::I64,
    "bool" => Type::Bool,
    "[]" <type_declaration> => Type::Array(Box::new(<>)),
};

number: Box<Expr> = r"[0-9]+" => Box::new(Expr::Number(i64::from_str(<>).unwrap()));

boolean: Box<Expr> = {
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false)),
};

identifier: Box<Expr> = r"[a-zA-Z_]\w*" => Box::new(Expr::Variable(Variable::Id(<>.to_string())));