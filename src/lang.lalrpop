use std::str::FromStr;
use ast::{Ast, Statement, Type, TypePrimitive, Expr, Variable, Id, BinOp, Declaration, DeclarationData};

grammar;

// Macro for a comma-separated list, with an optional trailing comma
Comma<T>: Vec<T> = <v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};

// Macro for tiers of expression precedence
Tier<Op, NextTier>: Expr = {
    <lhs:Tier<Op, NextTier>> <op:Op> <rhs:NextTier> => Expr::Operation(Box::new(lhs), op, Box::new(rhs)),
    NextTier,
};

pub file: Ast = program => Ast::new(<>);

program = declaration*;

declaration = {
    function_declaration,
    variable_declaration,
};

function_declaration: Declaration = {
    "fn" <id:identifier>
    "(" <params:Comma<(<identifier> ":" <type_declaration>)>> ")"
    <ret_type:("->" <type_declaration>)?>
    "{" <stmts:statement*> "}" => {
        let ty = Type::Function {
            params,
            ret: Box::new(ret_type.unwrap_or(Type::Primitive(TypePrimitive::Void))),
        };
        Declaration {
            id,
            ty,
            data: DeclarationData::Function(stmts),
        }
    }
};

variable_declaration: Declaration = {
    "let" <id:identifier> ":" <ty:type_declaration>
    <expr:("=" <expression>)?>
    ";" => {
        Declaration {
            id,
            ty,
            data: DeclarationData::Variable(expr),
        }
    }
};

statement: Statement = {
    declaration => Statement::Declaration(<>),
    statement_expression,
    statement_assign,
    statement_if,
    statement_while,
    statement_return,
    statement_block,
};

statement_expression: Statement = <expression> ";" => Statement::Expression(<>);

statement_assign: Statement = <variable> "=" <expression> ";" => Statement::Assignment(<>);

statement_if: Statement = {
    "if" <comparison> "{" <statement*> "}"
    <("else" "{" <statement*> "}")?> => {
        Statement::If(<>)
    }
};

statement_while: Statement = "while" <comparison> "{" <statement*> "}" => Statement::Loop(<>);

statement_return: Statement = "return" <expression?> ";" => Statement::Return(<>);

statement_block: Statement = "{" <statement*> "}" => Statement::Block(<>);

comparison: Expr = <lhs:expression> <op:relational> <rhs:expression> => Expr::Operation(Box::new(lhs), op, Box::new(rhs));

expression = Tier<expression_operator, factor>;

factor = Tier<factor_operator, term>;

expression_operator: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

factor_operator: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

term: Expr = {
    "(" <expression> ")",
    number,
    boolean,
    function_call,
    variable => Expr::Variable(<>),
};

variable: Variable = {
    identifier => Variable::Id(<>),
    <id:identifier> "[" <index:expression> "]" => Variable::Vec {id, index: Box::new(index)},
};

function_call: Expr = <id:identifier> "(" <args:function_args> ")" => {
    Expr::FunctionCall{<>}
};

function_args: Vec<Expr> = Comma<expression>;

relational: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Ne,
    "<"  => BinOp::Lt,
    ">"  => BinOp::Gt,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
};

type_declaration: Type = {
    "int" => Type::Primitive(TypePrimitive::Int),
    "bool" => Type::Primitive(TypePrimitive::Bool),
    "void" => Type::Primitive(TypePrimitive::Void),
    "[]" <type_declaration> => Type::Array(Box::new(<>)),
};

number: Expr = r"[+-]?\d+" => Expr::Number(i64::from_str(<>).unwrap());

boolean: Expr = {
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
};

identifier: Id = r"[a-zA-Z_]\w*" => Id(<>.to_string());
