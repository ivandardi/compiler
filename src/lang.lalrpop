use std::str::FromStr;
use ast::{Ast, Function, Statement, Type, Expr, Variable, Id, BinOp};

grammar;

// Macro for a comma-separated list, with an optional trailing comma
Comma<T>: Vec<T> = <v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};

// Macro for tiers of expression precedence
Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::Operation(<>)),
    NextTier,
};

pub file: Ast = program => Ast::new(<>);

program = function_declaration*;

function_declaration: Function = {
    "fn" <id:identifier> "(" <params:function_params> ")" <ret_type:("->" <type_declaration>)?> "{" <stmts:statement*> "}" => {
        let ret = ret_type.unwrap_or(Type::Void);
        Function {
            id,
            params,
            ret,
            stmts,
        }
    }
};

function_params: Vec<(Id, Type)> = Comma<(<identifier> ":" <type_declaration>)>;

statement: Statement = {
    variable_declaration,
    expression_statement,
    assign_statement,
    if_statement,
    while_statement,
    return_statement,
    statement_block,
};

variable_declaration: Statement = {
    "let" <id:identifier> ":" <ty:type_declaration> <expr:("=" <expression>)?> ";" => Statement::VarDecl {<>},
};

expression_statement: Statement = <expression> ";" => Statement::Expression(<>);

assign_statement: Statement = <variable> "=" <expression> ";" => Statement::Assignment(<>);

if_statement: Statement = "if" <comparison> "{" <statement*> "}" <("else" "{" <statement*> "}")?> => Statement::If(<>);

while_statement: Statement = "while" <comparison> "{" <statement*> "}" => Statement::Loop(<>);

return_statement: Statement = "return" <expression?> ";" => Statement::Return(<>);

statement_block: Statement = "{" <statement*> "}" => Statement::Block(<>);

comparison: Box<Expr> = expression relational expression => Box::new(Expr::Operation(<>));

expression = Tier<expression_operator, factor>;

factor = Tier<factor_operator, term>;

term: Box<Expr> = {
    "(" <expression> ")",
    number,
    boolean,
    function_call,
    variable => Box::new(Expr::Variable(<>)),
};

variable: Variable = {
    identifier => Variable::Id(<>),
    <id:identifier> "[" <index:expression> "]" => Variable::Vec {<>},
};

function_call: Box<Expr> = <id:identifier> "(" <args:function_args> ")" => {
    Box::new(Expr::FunctionCall{<>})
};

function_args: Vec<Box<Expr>> = Comma<expression>;

relational: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Ne,
    "<"  => BinOp::Lt,
    ">"  => BinOp::Gt,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
};

expression_operator: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

factor_operator: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

type_declaration: Type = {
    "i64" => Type::I64,
    "bool" => Type::Bool,
    "void" => Type::Void,
    "[]" <type_declaration> => Type::Array(Box::new(<>)),
};

number: Box<Expr> = r"[+-]?\d+" => Box::new(Expr::Number(i64::from_str(<>).unwrap()));

boolean: Box<Expr> = {
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false)),
};

identifier: Id = r"[a-zA-Z_]\w*" => Id(<>.to_string());
